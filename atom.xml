<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ColorfulCat</title>
  
  <subtitle>云外有天，年月有歌</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dew667.github.io/"/>
  <updated>2020-07-07T15:25:39.471Z</updated>
  <id>https://dew667.github.io/</id>
  
  <author>
    <name>ColorfulCat</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap的底层实现</title>
    <link href="https://dew667.github.io/2020/07/07/HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>https://dew667.github.io/2020/07/07/HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-07-07T15:25:12.000Z</published>
    <updated>2020-07-07T15:25:39.471Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>HashMap底层是数组加链表组合起来使用的。当向HashMap中put一个键值对时，会计算出key的hashCode，然后通过扰动函数对hashCode值进行处理，以达到尽可能散列的目的，从而得到当前元素在数组中存储的位置。如果在该位置遇到已经存在的元素，则判断hash值以及Key是否相同，如果相同则覆盖之，不相同则采用“拉链法”解决冲突。</p><a id="more"></a></li><li><p>所谓扰动函数是指对元素key的hashcode进行扰动处理，达到减少在数组中碰撞的目的。</p></li><li><p>所谓拉链法是指HashMap的数组为链表数组，每一个数组位置上都是一个链表，可以存放一系列hash值发生碰撞的元素。</p></li><li><p>在JDK1.8之后，底层数据结构采用的是链表数组加红黑树。当数组位置上的链表长度超过8时转换为红黑树，以减少查询时间。</p></li><li><p>下面是JDK1.8之后HashMap的数据结构示意图：<br><img src="https://s1.ax1x.com/2020/07/07/UESA5n.jpg" alt="pic1"></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;HashMap底层是数组加链表组合起来使用的。当向HashMap中put一个键值对时，会计算出key的hashCode，然后通过扰动函数对hashCode值进行处理，以达到尽可能散列的目的，从而得到当前元素在数组中存储的位置。如果在该位置遇到已经存在的元素，则判断hash值以及Key是否相同，如果相同则覆盖之，不相同则采用“拉链法”解决冲突。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://dew667.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HashMap、Hashtable、HashSet比较</title>
    <link href="https://dew667.github.io/2020/07/07/HashMap%E3%80%81Hashtable%E3%80%81HashSet%E6%AF%94%E8%BE%83/"/>
    <id>https://dew667.github.io/2020/07/07/HashMap%E3%80%81Hashtable%E3%80%81HashSet%E6%AF%94%E8%BE%83/</id>
    <published>2020-07-06T16:44:28.000Z</published>
    <updated>2020-07-06T16:46:31.780Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HashMap-Hashtable-HashSet继承实现关系"><a href="#HashMap-Hashtable-HashSet继承实现关系" class="headerlink" title="HashMap Hashtable HashSet继承实现关系"></a>HashMap Hashtable HashSet继承实现关系</h3><p>下面是三者的继承实现关系示意图</p><a id="more"></a><p><img src="https://s1.ax1x.com/2020/07/07/UFZ5Fg.jpg" alt="pic1"></p><h3 id="HashMap-和HashTable-的区别"><a href="#HashMap-和HashTable-的区别" class="headerlink" title="HashMap 和HashTable 的区别."></a>HashMap 和HashTable 的区别.</h3><ul><li>线程安全: HashMap不是线程安全的，HashTable 是线程安全的。HashTable 中方法都有synchronized 修饰。如果要用线程安全的集合，可以考虑ConcurrentHashMap。</li><li>效率：因为线程安全的原因，HashTable 的效率要低于HashMap。</li><li>是否支持Null Key 和Null Value：HashMap支持为Null 的Key，但一个HashMap集合只能包含一个，同时HashMap支持使用多个值为Null的Value。HashTable则不行，若put进入Null则会报错：NullPointerException.</li><li>底层数据结构：1.8版本开始，HashMap底层数据结构为数组承载的链表或者红黑树，当链表长度大于阈值时，链表会转换为红黑树。HashTable中没有这样的机制。</li><li>初始容量和扩容：HashTable若不指定初始容量，则默认初始容量为11，以后每次扩容，都变为2n+1. HashMap若不指定初始容量，则默认容量为16，每次扩容都为原来两倍。HashTable 若指定初始容量，则初始容量为指定值。HashMap 若指定初始值，则初始容量为2的幂次。  </li></ul><h3 id="HashMap-和HashSet-的区别"><a href="#HashMap-和HashSet-的区别" class="headerlink" title="HashMap 和HashSet 的区别"></a>HashMap 和HashSet 的区别</h3><p>HashSet底层都是通过HashMap实现的。  </p><table><thead><tr><th align="center"><strong>HashMap</strong></th><th align="center"><strong>HashSet</strong></th></tr></thead><tbody><tr><td align="center">实现了Map接口</td><td align="center">实现了Set接口</td></tr><tr><td align="center">存储键值对</td><td align="center">存储对象元素</td></tr><tr><td align="center">put添加键值对</td><td align="center">add添加元素</td></tr><tr><td align="center">HashMap使用Key计算hashcode</td><td align="center">HashSet使用成员对象来计算hashcode</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HashMap-Hashtable-HashSet继承实现关系&quot;&gt;&lt;a href=&quot;#HashMap-Hashtable-HashSet继承实现关系&quot; class=&quot;headerlink&quot; title=&quot;HashMap Hashtable HashSet继承实现关系&quot;&gt;&lt;/a&gt;HashMap Hashtable HashSet继承实现关系&lt;/h3&gt;&lt;p&gt;下面是三者的继承实现关系示意图&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://dew667.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>说一说ArrayList的扩容机制</title>
    <link href="https://dew667.github.io/2020/07/07/%E8%AF%B4%E4%B8%80%E8%AF%B4ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
    <id>https://dew667.github.io/2020/07/07/%E8%AF%B4%E4%B8%80%E8%AF%B4ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</id>
    <published>2020-07-06T16:04:02.000Z</published>
    <updated>2020-07-06T16:05:21.158Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md" target="_blank" rel="noopener">ArrayList 扩容机制源码分析</a>  </p><ul><li><p>通过ArrayList构造方法初始化时，可以带初始容量，则为ArrayList列表设置指定初始容量。</p></li><li><p>如果通过ArrayList构造方法初始化，不带初始容量参数，则ArrayList列表中的数据初始化为空的Object[]数组，其长度为0，即DEFEAULTCAPACITY_ELEMENT_DATA。之后在第一次调用add()方法添加元素时才会初始化数组容量为默认大小10.</p><a id="more"></a></li><li><p>当调用add()方法添加元素时，首先会比较扩容大小和默认大小10，如果是第一次扩容，则会在grow()方法中扩展数组大小为10。一般情况下，每次扩容时，都会将数组大小扩展为原来的1.5倍。</p></li><li><p>扩容时，会用到System.arrycopy方法。这里会新建一个扩容后的数组，将原来数组中的数据拷贝过去，在将ArrayList中elementData数组引用指向新数组，这样就完成了扩容。</p></li><li><p>在我们用add()方法添加大量元素之前，可以调用ensureCapacity()方法来扩容，以减少容量重新分配的次数。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ArrayList 扩容机制源码分析&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过ArrayList构造方法初始化时，可以带初始容量，则为ArrayList列表设置指定初始容量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果通过ArrayList构造方法初始化，不带初始容量参数，则ArrayList列表中的数据初始化为空的Object[]数组，其长度为0，即DEFEAULTCAPACITY_ELEMENT_DATA。之后在第一次调用add()方法添加元素时才会初始化数组容量为默认大小10.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://dew667.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList,Vector,LinkedList集合的比较</title>
    <link href="https://dew667.github.io/2020/07/06/ArrayList-Vector-LinkedList%E9%9B%86%E5%90%88%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>https://dew667.github.io/2020/07/06/ArrayList-Vector-LinkedList%E9%9B%86%E5%90%88%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2020-07-06T15:01:07.000Z</published>
    <updated>2020-07-06T15:04:23.992Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ArrayList、Vector、LinkedList三者的继承实现关系"><a href="#ArrayList、Vector、LinkedList三者的继承实现关系" class="headerlink" title="ArrayList、Vector、LinkedList三者的继承实现关系"></a>ArrayList、Vector、LinkedList三者的继承实现关系</h3><p>ArrayList、LinkedList、Vector都实现了List接口，而LinkedList还实现了Queue接口。因而，ArrayList、Vector都有列表的基本方法add、remove、get、set等，LinkedList除具有List的基本方法外还有队列的一些方法如poll、peek等。 </p><a id="more"></a><p>下图展示了三者的继承实现关系：<br><img src="https://s1.ax1x.com/2020/07/06/UixDjH.jpg" alt="pic1"></p><h3 id="ArrayList-与LinkedList-的区别"><a href="#ArrayList-与LinkedList-的区别" class="headerlink" title="ArrayList 与LinkedList 的区别"></a>ArrayList 与LinkedList 的区别</h3><ul><li>是否线程安全：由于ArrayList 和Linkedlist 都不是同步的，所以不是保证线程安全的。</li><li>底层数据结构：ArrayList 底层数据结构采用的是Object数组，而LinkedList底层数据结构采用的是双向链表（JDK1.7之前为双向循环链表，1.7开始取消循环）。</li><li>删除和插入的时间复杂度：ArrayList由于采用数组作为底层数据结构，所以在中间某一位置删除或插入元素，其时间复杂度为O(n-i)，因为插入时需要将i位置后面n-i个元素后移，删除时则需要前移。LinkedList由于采用双向链表作为底层数据结构，所以插入和删除元素不受位置因素影响，时间复杂度都是O(1)。</li><li>是否支持随机访问：ArrayList支持随机访问而LinkedList不支持随机访问，因为ArrayList采用数组，数组是天然支持随机访问的，链表就不行，访问元素需要遍历。因此，ArrayList实现了RandomAccess这一接口，而LinkedList没有。RandomAccess接口就是一种随机访问的标记。</li><li>内存空间占用：ArrayList内存占用冗余之处体现在需要预留一定的数组末尾空间，而LinkedList内存占用体现在每一个链表节点都有前驱、后继和数据。 </li></ul><p><em><strong>附</strong> RandomAceess与循环遍历方法</em><br>实现了RandomAccess接口的list，优先选择普通for 循环， 其次foreach<br>未实现RandomAccess接口的list，优先选择iterator 遍历(foreach底层也是通过iterator实现的)，大size的数据，千万不要用for 循环<br>采用上述遍历策略才能节省时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess)&#123;</span><br><span class="line">            System.out.println(<span class="string">"实现了RandomAccess接口，不使用迭代器"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">                System.out.println(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"没实现RandomAccess接口，使用迭代器"</span>);</span><br><span class="line"></span><br><span class="line">            Iterator it = list.iterator();</span><br><span class="line">            <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                System.out.println(it.next());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList与Vector的区别？为什么要用ArrayList取代Vector呢？"><a href="#ArrayList与Vector的区别？为什么要用ArrayList取代Vector呢？" class="headerlink" title="ArrayList与Vector的区别？为什么要用ArrayList取代Vector呢？"></a>ArrayList与Vector的区别？为什么要用ArrayList取代Vector呢？</h3><ul><li>Vector类中的所有方法都是同步的，所以可以由两个或多个线程安全的访问一个Vector对象，但是一个线程访问Vector的话要在同步操作上耗费大量的时间。  </li><li>ArrayList不是同步的，所以在不需要保证线程安全的情况下建议使用ArrayList。  </li><li>ArrayList与Vector初始容量都为10，但在容量不足的情况下，ArrayList缺省情况下自动增长50%，而Vector在缺省情况下自动增长1倍。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ArrayList、Vector、LinkedList三者的继承实现关系&quot;&gt;&lt;a href=&quot;#ArrayList、Vector、LinkedList三者的继承实现关系&quot; class=&quot;headerlink&quot; title=&quot;ArrayList、Vector、LinkedList三者的继承实现关系&quot;&gt;&lt;/a&gt;ArrayList、Vector、LinkedList三者的继承实现关系&lt;/h3&gt;&lt;p&gt;ArrayList、LinkedList、Vector都实现了List接口，而LinkedList还实现了Queue接口。因而，ArrayList、Vector都有列表的基本方法add、remove、get、set等，LinkedList除具有List的基本方法外还有队列的一些方法如poll、peek等。 &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://dew667.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java常见基础知识(续)</title>
    <link href="https://dew667.github.io/2020/07/05/Java%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%BB%AD/"/>
    <id>https://dew667.github.io/2020/07/05/Java%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%BB%AD/</id>
    <published>2020-07-05T09:25:42.000Z</published>
    <updated>2020-07-05T09:27:34.067Z</updated>
    
    <content type="html"><![CDATA[<h3 id="26-为什么Java中只有值传递？"><a href="#26-为什么Java中只有值传递？" class="headerlink" title="26.为什么Java中只有值传递？"></a>26.为什么Java中只有值传递？</h3><p>Java中方法采用是值传递而不是引用调用，即方法接收的是参数的一份拷贝。<br>总结：</p><ul><li>Java中方法不能修改一个基本数据类型的参数。</li><li>Java中方法可以改变一个对象参数的状态。</li><li>Java中方法不能让对象参数引用一个新的对象。</li></ul><a id="more"></a><h3 id="27-简述程序、进程、线程的概念。以及它们之间的关系？"><a href="#27-简述程序、进程、线程的概念。以及它们之间的关系？" class="headerlink" title="27.简述程序、进程、线程的概念。以及它们之间的关系？"></a>27.简述程序、进程、线程的概念。以及它们之间的关系？</h3><ul><li>程序<br>程序可以定义为算法加数据，一个程序可以是存放在计算机存储空间中的代码集合，例如浏览器就是一个程序。</li><li>进程<br>计算机操作系统可以实现多任务功能。为了实现多任务，操作系统必须利用好CPU，可以通过CPU分时或者多核CPU来实现。而一个任务可以理解为一个进程。操作系统为一个进程分配一定的内存存储空间和CPU时间以及文件、设备的控制权。进程通过这些资源实现自己的任务功能。</li><li>线程<br>线程可以理解为一个进程中更细粒度的运行单位。一个进程可以通过多个线程同时执行多个子功能模块。多个线程共享进程的内存存储空间、系统资源，因而线程之间通信和切换等操作比较方便。</li><li>进程、线程之间的关系<br>进程是操作系统执行多任务的基本运行单位，而线程是进程内更细粒度的基本运行单位。操作系统为进程分配内存存储空间、CPU时间、文件和设备控制器等资源，进程内部的线程共享该进程的内存存储空间等资源。线程之间通信和切换操作相较进程之间更加方便。</li></ul><h3 id="28-线程有哪些基本状态？"><a href="#28-线程有哪些基本状态？" class="headerlink" title="28.线程有哪些基本状态？"></a>28.线程有哪些基本状态？</h3><ol><li>Java中线程的基本状态有NEW、RUNNABLE、WAITING、TIMED_WAITING、BLOCKED、TERMINATED。即初始状态、运行状态、等待状态、超时等待状态、阻塞状态、终止状态。  </li></ol><table><thead><tr><th align="center">状态</th><th align="center">名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">NEW</td><td align="center">初始状态</td><td align="center">线程被创建但还未调用start()方法</td></tr><tr><td align="center">RUNNABLE</td><td align="center">运行状态</td><td align="center">Java中将就绪状态和运行状态笼统地称为RUNNABLE状态</td></tr><tr><td align="center">WAITING</td><td align="center">等待状态</td><td align="center">线程等待其他线程的通知</td></tr><tr><td align="center">TIMED_WAITING</td><td align="center">超时等待状态</td><td align="center">等待一段时间线程可以自行回到RUNNABLE状态</td></tr><tr><td align="center">BLOCKED</td><td align="center">阻塞状态</td><td align="center">线程执行同步方法时，未获取到锁则进入阻塞状态</td></tr><tr><td align="center">TERMINATED</td><td align="center">终止状态</td><td align="center">线程执行结束</td></tr></tbody></table><p><img src="https://s1.ax1x.com/2020/04/10/GoY9Og.png" alt="java线程">  </p><blockquote><p>线程创建之后，进入NEW状态，即初始状态。调用start()方法后线程进入READY状态(就绪状态)，当分配到CPU时间片后，即进入RUNNING状态(运行)。在Java中，把READY和RUNNING状态笼统地称为RUNNABLE状态。如果线程执行wait()方法，则线程进入WAITING状态(等待状态)。在此状态下只有其它线程通知，才能回到运行状态。TIMED_WAITING状态(超时等待状态)则是在WAITING状态基础上加上时间限制，例如sleep(long)，当时间到后线程回到运行状态。如果线程要调用同步方法而没有获取到锁，则进入BLOCKED(阻塞状态)。在此状态下如果获取到锁则回到运行状态。线程执行完毕，进入TERMINATED状态(终止状态)。</p></blockquote><h3 id="29-关于final关键字的一些总结"><a href="#29-关于final关键字的一些总结" class="headerlink" title="29.关于final关键字的一些总结"></a>29.关于final关键字的一些总结</h3><p>final关键字用法有三种：用于变量、用于类、用于方法。  </p><ol><li>final关键字用于变量<br>final用于基本数据类型变量时，变量一旦被初始化就不能再修改。如果用于引用类型变量，则引用类型变量一旦初始化对象后就不能再更改引用指向。</li><li>final关键字用于类<br>final关键字用于类时，表明该类不能被继承。另外，final关键字修饰的类中的方法都隐式地指定为final</li><li>final关键字用于方法<br>final关键字用于方法，则该方法不能被子类重写。private修饰的方法都被隐式地指定为final。</li></ol><h3 id="30-Java异常处理"><a href="#30-Java异常处理" class="headerlink" title="30.Java异常处理"></a>30.Java异常处理</h3><ul><li>Java异常结构层次<br><img src="https://s1.ax1x.com/2020/04/10/GoYiwj.png" alt="Java异常处理"></li><li>Java异常处理<br>Java中所有异常都有一个共同的祖先，即java.lang包中的Throwable类。Thorwable有两个重要的子类Error和Exception。Error是程序无法处理的错误，一般是程序运行时JVM发生的错误，如内存用尽时OutOfMemoryError。Exception是程序可以处理的异常，如要访问的变量没有引用任何对象时NullPointerException。<br>Error和Exception之间的不同之处是Error是程序本身不可以处理的错误，而Exception是程序本身可以处理的异常。  </li><li>Throwable类常用方法  <ol><li>public String getMessage() 返回异常发生时的简要描述</li><li>public String toString() 返回异常发生时的详细信息</li><li>public void printStackTrace() 在控制台上打印Throwable对象封装的异常信息</li></ol></li><li>Try-Catch块的使用<br>try块用于捕获异常，其后可接一个或多个catch块。如果没有接catch块，则其后必须接finally块。<br>catch块用于处理异常。<br>finally块：无论是否捕获或处理异常，finally块中的语句都会被执行。如果在之前try块或catch块中已有return语句，则finally块中的内容会在return之前先执行。如果不仅try块中有return语句，而且finally块中也有return语句，则返回前先执行finally块内容，finally块中的return语句代替try中return。  </li><li>不会执行finally块的情况<ol><li>finally块中第1行语句发生异常。</li><li>前面已用System.exit(int)退出程序</li><li>所在线程死亡</li><li>CPU关闭</li></ol></li></ul><h3 id="31-Java序列化中如果有些字段不想序列化，怎么办？"><a href="#31-Java序列化中如果有些字段不想序列化，怎么办？" class="headerlink" title="31.Java序列化中如果有些字段不想序列化，怎么办？"></a>31.Java序列化中如果有些字段不想序列化，怎么办？</h3><p>对实例中不想进行序列化的字段使用transient关键字修饰。<br>transient关键字只能修饰变量，不能修饰类和方法。</p><h3 id="32-获取键盘输入常用的方法？"><a href="#32-获取键盘输入常用的方法？" class="headerlink" title="32.获取键盘输入常用的方法？"></a>32.获取键盘输入常用的方法？</h3><ul><li>Scanner  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure><ul><li>BufferedReader  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input &#x3D; new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">String s &#x3D; input.readLine();</span><br></pre></td></tr></table></figure><h3 id="33-Java中IO流分为几种？"><a href="#33-Java中IO流分为几种？" class="headerlink" title="33.Java中IO流分为几种？"></a>33.Java中IO流分为几种？</h3><ul><li>分类  <ol><li>按照方向分为输入流和输出流</li><li>按照操作单位分为字符流和字节流</li><li>按照流的角色分为节点流和处理流</li></ol></li><li>为什么有了字节流还要有字符流<br>因为字符流是Java虚拟机通过字节流转换而来的，转换过程比较费时而且不知道编码的情况下容易乱码，所以Java索性提供了字符流接口。</li></ul><h3 id="34-BIO、NIO、AIO有什么区别"><a href="#34-BIO、NIO、AIO有什么区别" class="headerlink" title="34.BIO、NIO、AIO有什么区别?"></a>34.BIO、NIO、AIO有什么区别?</h3><ul><li>BIO<br>BIO是指同步阻塞IO模式。这种模式下，数据操作必须阻塞在一个线程内等待其完成。即需要维持一个连接，而且客户端不能做其他事情。BIO模式的优点是使用起来直观、简单，能够应对并发量较小的情况。缺点是，当并发量过大时服务器负担较大，无法很好地应对。</li><li>NIO<br>NIO是指同步非阻塞IO模式。这种模式下，客户端与服务端之间不需要保持一个连接，而是分成许多小的连接。客户端向服务端轮询，如果没有数据则断开连接，直到有数据为止。客户端与服务端不需要维持连接，客户端也不可以做其他事情。NIO模型相较BIO能够更好地应对高负载、高并发的情况。</li><li>AIO<br>AIO是指异步非阻塞IO模型。在这种模式下，客户端与服务端之间不用保持连接，也不用轮询方式。而是在服务端处理完成后能够通知客户端并返回数据。客户端在得到数据之前可以做其他事情。目前来说，AIO应用并不广泛。  </li></ul><h3 id="35-常见关键字总结：final、static、this、super"><a href="#35-常见关键字总结：final、static、this、super" class="headerlink" title="35.常见关键字总结：final、static、this、super"></a>35.常见关键字总结：final、static、this、super</h3><ul><li>final<br>final关键字主要可以用在三个地方:变量、类、方法.<ul><li>final关键字用于变量： final关键字如果用于基本数据类型的变量，则该变量一旦初始化，就不可以修改其值；如果用于引用类型变量，则一旦该变量初始化，就不可以改变引用对象。</li><li>final关键字用于类： final关键字用于类，表明该类不可以被继承。并且final关键字修饰的类，其中的方法隐式地被修饰final关键字。</li><li>final关键字用于方法： final关键字修饰方法，主要有两个作用。一是表明该方法不可被子类重写。二是在早期Java版本中，使用内嵌调用方式以提高性能。</li></ul></li><li>static<br>static关键字可以用在四个地方：修饰类的成员、静态代码块、修饰内部类、静态导包  <ul><li>static关键字用于修饰类的成员： static修饰类的成员时，这些成员属于类而不属于类的实例对象，可以用类名.成员名的方式访问这些成员。如果static修饰的是成员变量，则成员变量存放在内存方法区中。如果static修饰的是成员方法，则在该方法内只能访问static修饰的变量或方法。</li><li>static关键字用于静态代码块： 静态代码块是在非静态代码块之前执行，且对于一个类的所有实例对象只执行一次。</li><li>static关键字用于内部类： static修饰内部类，则该内部类不具有外部类的引用，因此该内部类的创建不需要依赖外部类，同时该内部类只能访问外部类的static修饰的成员。</li><li>static关键字用于静态导包： 静态导包可以不需要通过类名来访问其中的成员。</li></ul></li><li>this<br>this关键字用于引用类的当前实例。</li><li>super<br>super关键字用于子类访问父类的成员。  </li></ul><h3 id="36-深拷贝和浅拷贝"><a href="#36-深拷贝和浅拷贝" class="headerlink" title="36.深拷贝和浅拷贝"></a>36.深拷贝和浅拷贝</h3><p>拷贝一个对象时分为深拷贝和浅拷贝</p><ul><li>浅拷贝<br>浅拷贝是指拷贝时，对基本数据类型的拷贝以值传递方式进行，而拷贝引用类型则只是对引用进行传递，因此拷贝前后两个对象中的引用类型仍然指向同一个对象，对两个对象中引用对象的数据进行修改会相互影响。</li><li>深拷贝<br>深拷贝是指拷贝时，对基本数据类型的拷贝以值传递方式进行，并且拷贝引用类型变量时新建一个对象的空间并复制其中的内容。这样两个对象中引用的对象不是同一个。</li><li>浅拷贝和深拷贝的一种实现方式是类实现Cloneable接口，并且重写clone()方法。如果要做到深拷贝，则引用类型也需要实现Cloneable接口并重写clone()方法。</li></ul><p><strong>参考</strong></p><p>[1] JavaGuide面试突击版[<a href="https://gitee.com/SnailClimb/JavaGuide]" target="_blank" rel="noopener">https://gitee.com/SnailClimb/JavaGuide]</a>(</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;26-为什么Java中只有值传递？&quot;&gt;&lt;a href=&quot;#26-为什么Java中只有值传递？&quot; class=&quot;headerlink&quot; title=&quot;26.为什么Java中只有值传递？&quot;&gt;&lt;/a&gt;26.为什么Java中只有值传递？&lt;/h3&gt;&lt;p&gt;Java中方法采用是值传递而不是引用调用，即方法接收的是参数的一份拷贝。&lt;br&gt;总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java中方法不能修改一个基本数据类型的参数。&lt;/li&gt;
&lt;li&gt;Java中方法可以改变一个对象参数的状态。&lt;/li&gt;
&lt;li&gt;Java中方法不能让对象参数引用一个新的对象。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java常见基础知识</title>
    <link href="https://dew667.github.io/2020/04/10/Java%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://dew667.github.io/2020/04/10/Java%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-04-10T04:02:53.000Z</published>
    <updated>2020-07-05T09:27:55.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1.面向对象和面向过程的区别"></a>1.面向对象和面向过程的区别</h3><ul><li><p>面向过程相较面向对象通常资源开销较小，性能更占优势。因为面向对象中类的调用需要实例化。通常用在嵌入式、底层开发等对资源占用或性能要求较高的场合。</p></li><li><p>面向对象更加易于维护、扩展和复用，因为面向对象加入了封装、继承、多态等特性。面向对象语言可以设计出更加灵活、易于维护和扩展的系统。</p><a id="more"></a></li></ul><h3 id="2-Java语言的特点"><a href="#2-Java语言的特点" class="headerlink" title="2.Java语言的特点"></a>2.Java语言的特点</h3><ol><li>易用 Java语言摒弃了C++中一些让人易迷惑的特性和语法，语言更加容易掌握</li><li>面向对象 封装、继承、多态</li><li>Java虚拟机让Java语言具有平台无关性</li><li>安全</li><li>支持网络编程 Java中具有这方面的类库</li><li>支持多线程 Java本身具有多线程功能，无需调用操作系统的多线程API</li><li>可靠性</li><li>编译与解释并存</li></ol><h3 id="3-JVM、JRE和JDK"><a href="#3-JVM、JRE和JDK" class="headerlink" title="3.JVM、JRE和JDK"></a>3.JVM、JRE和JDK</h3><ul><li>JVM<br>JVM即Java虚拟机，它是用来运行Java字节码的。Java字节码.class文件是.java源文件经过javac工具编译后得到的。JVM则读取.class字节码文件，通过解释器解释执行命令。也就是说，Java语言通过JVM实现了解释型语言的跨平台特性，并且通过.class文件实现了速度上的提高，能够做到一次编译，随处执行。在JVM的发展过程中出现了JIT，通过保存热点代码的机器码实现了运行速度的提高。</li><li>JRE和JDK<ol><li>JDK即Java Development Kit，它包含了JRE的全部内容和javac编译工具以及javadoc等辅助工具。</li><li>JRE是Java运行时环境。Java Runtime Environment，它是机器运行Java程序的基本工具。</li><li>如果要开发基于Java的程序，则需要安装JDK，如果只是用来运行Java程序，则只需安装JRE。但并不绝对，比如在运行基于JSP的服务端程序时，需要安装JDK，因为JSP代码需要用到JDK编译Servlet程序。</li></ol></li></ul><h3 id="4-OracleJDK和OpenJDK"><a href="#4-OracleJDK和OpenJDK" class="headerlink" title="4.OracleJDK和OpenJDK"></a>4.OracleJDK和OpenJDK</h3><ol><li>OpenJDK是免费开源的，而OracleJDK并不是完全开源的。</li><li>OracleJDK和OpenJDK的代码基本相同，有大量重合的部分.</li><li>OracleJDK的稳定性和JVM性能要优于OpenJDK。</li></ol><h3 id="5-Java和C-的区别"><a href="#5-Java和C-的区别" class="headerlink" title="5.Java和C++的区别"></a>5.Java和C++的区别</h3><ol><li>Java和C++都是面向对象语言，都具有封装、继承、多态特性。</li><li>Java不支持通过指针访问内存，程序内存更加安全</li><li>Java的类不支持多继承，而C++支持多继承，但是Java中接口可以多继承</li><li>Java提供了自动内存管理机制，不需要手动释放无用的内存</li><li>C++中字符数组和字符串都以”\0”标记结尾,而Java中没有这一概念  </li></ol><h3 id="6-字符型常量和字符串常量的区别"><a href="#6-字符型常量和字符串常量的区别" class="headerlink" title="6.字符型常量和字符串常量的区别"></a>6.字符型常量和字符串常量的区别</h3><ul><li>字符型常量是单引号引起的一个字符，而字符串常量是双引号引起的若干字符。</li><li>字符型常量相当于一个整型值，可以参与运算(ASCII码)，字符串常量相当于一个地址，保存该字符串在内存中的位置。</li><li>字符型常量占2字节，字符串常量占若干字节.</li></ul><h3 id="7-Java基本类型的大小"><a href="#7-Java基本类型的大小" class="headerlink" title="7.Java基本类型的大小"></a>7.Java基本类型的大小</h3><table><thead><tr><th align="center">基本类型</th><th align="center">大小</th><th align="center">最小值</th><th align="center">最大值</th><th align="center">包装类型</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">Boolean</td></tr><tr><td align="center">byte</td><td align="center">8 bits</td><td align="center">-128</td><td align="center">127</td><td align="center">Byte</td></tr><tr><td align="center">char</td><td align="center">16 bits</td><td align="center"></td><td align="center"></td><td align="center">Character</td></tr><tr><td align="center">void</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">Void</td></tr><tr><td align="center">short</td><td align="center">16 bits</td><td align="center">-2E15</td><td align="center">2E15-1</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">32 bits</td><td align="center">-2E31</td><td align="center">2E31-1</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">64 bits</td><td align="center">-2E63</td><td align="center">2E63-1</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">32 bits</td><td align="center">1.4E-45</td><td align="center">3.4E38</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">64 bits</td><td align="center">1.80E308</td><td align="center">4.9E-324</td><td align="center">Double</td></tr></tbody></table><h3 id="8-构造器Constructor是否可被override？"><a href="#8-构造器Constructor是否可被override？" class="headerlink" title="8.构造器Constructor是否可被override？"></a>8.构造器Constructor是否可被override？</h3><p>Constructor不能被重写（Override），但可以重载（Overload），所以可以见到一个类中有多个构造函数的情况。</p><h3 id="9-重载和重写的区别"><a href="#9-重载和重写的区别" class="headerlink" title="9.重载和重写的区别"></a>9.重载和重写的区别</h3><ul><li>重载是一个类中多态特性的体现。即同名的方法根据传入参数的不同而具有不同的反应。重载方法可以具有不同的参数列表、参数顺序，也可以具有不同的访问修饰符和返回值类型。但是需要注意的是不允许出现这样的重载方法：方法名相同，参数列表相同但是仅仅返回值类型不同。</li><li>重写是类继承中多态特性的体现。即子类对父类中的方法进行覆盖，具有不同的实现过程。重写要求子类中的重写方法与父类被重写的方法具有相同的参数列表，返回值类型只能范围更小，访问修饰符范围更大，抛出异常类型范围更小。</li></ul><h3 id="10-Java面向对象三大特性：封装、继承、多态"><a href="#10-Java面向对象三大特性：封装、继承、多态" class="headerlink" title="10.Java面向对象三大特性：封装、继承、多态"></a>10.Java面向对象三大特性：封装、继承、多态</h3><ul><li>封装<br>封装是将类的属性私有化，不允许外部直接使用这些属性，而提供一些方法让外部间接调用这些属性。</li><li>继承<br>继承是指继承一个类的属性和方法的技术，子类可以继承父类的属性的方法，并且可以添加自己的属性和方法，以及重写父类中的方法。继承可以使得代码可以较好地复用。</li><li>多态<br>多态是指同一个行为具有不同地表现形式或形态大的能力。多态分为重载式多态和重写式多态。重载即同名的方法根据传入参数的不同执行不同的过程。在Java中表现为重载方法，是一种编译时多态。而重写式多态是一种运行时多态。在执行期判断引用对象的类型，从而执行相应的方法。</li></ul><h3 id="11-String-StringBuilder和StringBuffer的区别是什么？String为什么是不可变的"><a href="#11-String-StringBuilder和StringBuffer的区别是什么？String为什么是不可变的" class="headerlink" title="11.String StringBuilder和StringBuffer的区别是什么？String为什么是不可变的?"></a>11.String StringBuilder和StringBuffer的区别是什么？String为什么是不可变的?</h3><p>String类中使用final关键字修饰字符数组来保存字符串数据 private final char[] value 因而String对象是不可变的。<br>StringBuilder和StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder类中字符串数据没有使用final关键字，因而这两种对象的字符串是可以改变的。<br>StringBuilder中没有对方法加同步锁Synchronized，而StringBuffer中方法都加了同步锁。因而StringBuilder不是线程安全的，而StringBuffer是线程安全的。<br>但是StringBuilder的性能要稍微由于StringBuffer。</p><h3 id="12-自动拆箱与自动装箱"><a href="#12-自动拆箱与自动装箱" class="headerlink" title="12.自动拆箱与自动装箱"></a>12.自动拆箱与自动装箱</h3><p>自动拆箱: 将基本类型包装为对应的引用类型。<br>自动拆箱：将包装类型转换为基本数据类型。</p><h3 id="13-在一个静态方法里调用一个非静态成员为什么是非法的？"><a href="#13-在一个静态方法里调用一个非静态成员为什么是非法的？" class="headerlink" title="13.在一个静态方法里调用一个非静态成员为什么是非法的？"></a>13.在一个静态方法里调用一个非静态成员为什么是非法的？</h3><p>静态方法属于该类的所有对象共有，而非静态成员属于某一对象所有。因而静态方法中调用非静态成员是不被允许的。</p><h3 id="14-在Java中定义一个不做事且不带参数的构造方法的作用？"><a href="#14-在Java中定义一个不做事且不带参数的构造方法的作用？" class="headerlink" title="14.在Java中定义一个不做事且不带参数的构造方法的作用？"></a>14.在Java中定义一个不做事且不带参数的构造方法的作用？</h3><p>Java中如果子类构造方法中没有用<code>super()</code>去显式调用父类的某一构造方法，则会默认调用父类中没有参数的构造方法。如果父类中没有定义无参数的构造方法。则编译时会出错，因为找不到无参数的构造方法。所以我们可以去定义一个不做事且不带参数的构造方法填补缺位。</p><h3 id="14-import-java-和-javax-有什么区别？"><a href="#14-import-java-和-javax-有什么区别？" class="headerlink" title="14.import java 和 javax 有什么区别？"></a>14.import java 和 javax 有什么区别？</h3><p>最初JavaAPI所必须的包是java包，javax包只是用来扩展。但随着java语言的发展，javax包也成为javaAPI的组成部分。但是将javax包中的代码迁移到java包中十分麻烦，会破坏原有代码。因此就把javax包也纳入到标准API的一部分。</p><h3 id="15-接口和抽象类的区别"><a href="#15-接口和抽象类的区别" class="headerlink" title="15.接口和抽象类的区别"></a>15.接口和抽象类的区别</h3><ol><li>接口的方法修饰符为public(JDK9可以为private)，接口方法只能是空实现（JDK8开始可以有默认实现）。而抽象类的方法修饰符可以为public、private、protected和default。并且抽象类方法可以为抽象方法也可以有默认实现，即非抽象方法。</li><li>接口中不能包含成员变量，只能是private static final 修饰的变量，而抽象类中可以有自己的成员变量。</li><li>接口是对行为的抽象，是行为规范，而抽象类是对类的抽象，是模板设计。</li><li>一个类可以实现多个接口，但只能继承一个抽象类。</li></ol><h3 id="16-成员变量与局部变量的区别有哪些？"><a href="#16-成员变量与局部变量的区别有哪些？" class="headerlink" title="16.成员变量与局部变量的区别有哪些？"></a>16.成员变量与局部变量的区别有哪些？</h3><ol><li>从归属上看，成员变量属于类或者实例，而局部变量存在于方法内部。成员变量可以被public、private、static等修饰符修饰，而局部变量不能被访问控制修饰符及static修饰。但是两者都可以被final关键字修饰。</li><li>从生存周期上看，成员变量随着类的实例的创建而出生和消亡，而局部变量随着方法调用生存和消亡。</li><li>从内存存储方式上看，成员变量如果有static修饰，则属于类，否则属于实例。而对象存在于堆内存，局部变量则存在于栈内存。</li><li>成员变量如果没有被显式地赋初值，则会赋予类型默认值。（如果有final关键字修饰则例外）局部变量则必须显式地赋予初值。</li></ol><h3 id="17-创建一个对象用什么运算符？对象引用与对象实体有什么区别？"><a href="#17-创建一个对象用什么运算符？对象引用与对象实体有什么区别？" class="headerlink" title="17.创建一个对象用什么运算符？对象引用与对象实体有什么区别？"></a>17.创建一个对象用什么运算符？对象引用与对象实体有什么区别？</h3><p>用new运算符。对象实体存在于堆内存中，而对象引用存在于栈内存中。对象引用用来指向对象实体。一个对象引用可以不指向对象实体，也可以指向一个对象实体。而一个对象实体可以被多个对象引用所指。</p><h3 id="18-什么是方法的返回值？返回值在类的方法里的作用是什么？"><a href="#18-什么是方法的返回值？返回值在类的方法里的作用是什么？" class="headerlink" title="18.什么是方法的返回值？返回值在类的方法里的作用是什么？"></a>18.什么是方法的返回值？返回值在类的方法里的作用是什么？</h3><p>方法的返回值是一个方法执行后返回的结果。方法产生的返回值用于进行其他的操作。</p><h3 id="19-一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"><a href="#19-一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？" class="headerlink" title="19.一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"></a>19.一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</h3><p>类的构造方法的作用是完成初始化对象的工作。可以。因为这种情况会执行默认的不带参数的构造方法。</p><h3 id="20-构造方法有哪些特性？"><a href="#20-构造方法有哪些特性？" class="headerlink" title="20.构造方法有哪些特性？"></a>20.构造方法有哪些特性？</h3><ol><li>名字与类名相同。</li><li>不需显式调用，在生成对象时自动执行。</li><li>没有返回值，不能声明返回值类型为void。</li></ol><h3 id="21-静态方法和实例方法有何不同？"><a href="#21-静态方法和实例方法有何不同？" class="headerlink" title="21.静态方法和实例方法有何不同？"></a>21.静态方法和实例方法有何不同？</h3><p>静态方法可以用类名.方法名或者对象名.方法名的方式调用，而实例方法只能用后一种方式。也就是说，静态方法可以不通过创建对象实例的方式去调用，静态方法为类的所有对象所共有。<br>静态方法中只能调用静态成员，即静态属性和静态方法，而实例方法不受此限制。  </p><h3 id="22-对象的相等与指向他们的引用相等，两者有什么不同？"><a href="#22-对象的相等与指向他们的引用相等，两者有什么不同？" class="headerlink" title="22.对象的相等与指向他们的引用相等，两者有什么不同？"></a>22.对象的相等与指向他们的引用相等，两者有什么不同？</h3><p>对象的相等，比的是内存中的存放内容是否相等，而引用相等，指的是他们指向的内存地址是否相等。  </p><h3 id="23-在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#23-在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="23.在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>23.在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h3><p>帮助子类进行初始化工作。</p><h3 id="24-和equals"><a href="#24-和equals" class="headerlink" title="24.==和equals"></a>24.==和equals</h3><ul><li>如果是基本类型，==比较的是值是否相等；如果是引用类型，==比较的是指向的内存地址是否相同。</li><li>如果类中没有重写equals方法，则equals采用Object类中的方法，即比较内存地址是否相同。如果类中重写了equals方法，例如String类那样，则比较的是内容值是否相等。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss Example &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        <span class="keyword">if</span>(a == b) &#123; <span class="comment">// false</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a.equals(b)) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"a equals b"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String a1 = <span class="string">"abc"</span>;</span><br><span class="line">        String b1 = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="keyword">if</span>(a1 == b1) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"a1==b1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a1.equals(b1)) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"a1 equals b1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="25-hashCode-和equals"><a href="#25-hashCode-和equals" class="headerlink" title="25.hashCode()和equals"></a>25.hashCode()和equals</h3><ul><li>什么是hashCode?<br>hashCode即哈希码。它是用来在散列表中确定元素的索引位置的一种码。在散列表中，我们通过键值快速查询到对应元素就用到了哈希码。</li><li>介绍hashCode()哈希函数<br>hashCode()只在使用散列表时有作用。hashCode()函数就是用来生成哈希码的函数。hashCode()在Object类中存在，因此所有的类都有hashCode()函数。</li><li>为什么要有hashCode？<br>因为在诸如HashMap、HashSet、HashTable等Java集合类中本质是用到了散列表，通过hashcode来实现快速定位其中的元素。</li><li>为什么重写equals时必须重写hashCode()方法？<br>因为在我们使用HashMap、HashSet、HashTable这类集合时，对其中的元素要计算其hashCode哈希码。两个相同的对象，其hashcode一定要相同。如果我们不重写hashCode()方法，那么两个对象虽然用equals比较时是相同的，但hashcode却不同，这样就产生了矛盾，在使用上述集合类时也会产生错误。</li></ul><hr><p><strong>参考</strong></p><p>[1] JavaGuide面试突击版<a href="https://gitee.com/SnailClimb/JavaGuide" target="_blank" rel="noopener">https://gitee.com/SnailClimb/JavaGuide</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-面向对象和面向过程的区别&quot;&gt;&lt;a href=&quot;#1-面向对象和面向过程的区别&quot; class=&quot;headerlink&quot; title=&quot;1.面向对象和面向过程的区别&quot;&gt;&lt;/a&gt;1.面向对象和面向过程的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;面向过程相较面向对象通常资源开销较小，性能更占优势。因为面向对象中类的调用需要实例化。通常用在嵌入式、底层开发等对资源占用或性能要求较高的场合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;面向对象更加易于维护、扩展和复用，因为面向对象加入了封装、继承、多态等特性。面向对象语言可以设计出更加灵活、易于维护和扩展的系统。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="面经" scheme="https://dew667.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>记一次使用IDEA部署SSM项目时遇到的问题</title>
    <link href="https://dew667.github.io/2019/12/28/%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>https://dew667.github.io/2019/12/28/%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-12-28T08:45:08.000Z</published>
    <updated>2020-07-05T08:53:41.480Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">寒雨连江夜入吴，平明送客楚山孤。洛阳亲友如相问，一片冰心在玉壶。     《芙蓉楼送新辛渐》—— 王昌龄</blockquote><hr><p>本文介绍我在一次导入SSM项目时遇到的问题。（踩坑记录）</p><h4 id="IDEA导入SSM项目"><a href="#IDEA导入SSM项目" class="headerlink" title="IDEA导入SSM项目"></a>IDEA导入SSM项目</h4><hr><p>我要导入的项目是一个Github上的一个聊天室项目 <a href="https://github.com/MrLiu1227/WebChat" target="_blank" rel="noopener">Github链接</a> 首先import项目，选择Maven项目，勾选Import Maven projects automatically选项以及Automatically download的两个选项 </p><a id="more"></a><p><img src="https://s1.ax1x.com/2020/04/10/GoJLTA.png" alt="Maven"></p><p>等待Maven依赖下载完成后开始配置Tomcat。 点击Edit Configurations，并点击 “+” 配置Tomcat，在Deployment页面点击 ‘’+’’ 配置项目，选择WebChat:war exploded即可。</p><p><img src="https://s1.ax1x.com/2020/04/10/GoJqwd.png" alt="Maven2"></p><h4 id="导入SQL脚本"><a href="#导入SQL脚本" class="headerlink" title="导入SQL脚本"></a>导入SQL脚本</h4><hr><p>导入SQL脚本比较简单，通过IDEA配置数据源即可在IDE环境中自动导入SQL脚本</p><h4 id="Mysql依赖版本问题"><a href="#Mysql依赖版本问题" class="headerlink" title="Mysql依赖版本问题"></a>Mysql依赖版本问题</h4><hr><p>这里遇到了一些坑。</p><p>由于本机安装的是Mysql8.0，而Maven依赖中的是Mysql5，所以需要更改版本号。在pom.xml中找到mysql项，更改版本为8.0.11。 更改完毕还未结束。Mysql8.0版本需要重新配置数据连接池，将驱动Driver更改为</p><p><code>jdbc.driver=com.mysql.cj.jdbc.Driver</code> 以适配8.0版本，这里与5.0+版本不同</p><p>另外需要更改jdbc.url的时区和SSL设置 TimeZone设置为UTC，useSSL设置为false</p><p><code>jdbc.url=jdbc:mysql://127.0.0.1:3306/webchat?characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=UTC</code></p><p>这样就可以正常启动项目了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;寒雨连江夜入吴，平明送客楚山孤。洛阳亲友如相问，一片冰心在玉壶。 
    《芙蓉楼送新辛渐》—— 王昌龄&lt;/blockquote&gt;

&lt;hr&gt;
&lt;p&gt;本文介绍我在一次导入SSM项目时遇到的问题。（踩坑记录）&lt;/p&gt;
&lt;h4 id=&quot;IDEA导入SSM项目&quot;&gt;&lt;a href=&quot;#IDEA导入SSM项目&quot; class=&quot;headerlink&quot; title=&quot;IDEA导入SSM项目&quot;&gt;&lt;/a&gt;IDEA导入SSM项目&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;我要导入的项目是一个Github上的一个聊天室项目 &lt;a href=&quot;https://github.com/MrLiu1227/WebChat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github链接&lt;/a&gt; 首先import项目，选择Maven项目，勾选Import Maven projects automatically选项以及Automatically download的两个选项 &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Web开发" scheme="https://dew667.github.io/tags/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>(随笔)纪元系列——跨越世纪的模拟经营游戏佳作</title>
    <link href="https://dew667.github.io/2019/07/12/%E9%9A%8F%E7%AC%94-%E7%BA%AA%E5%85%83%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E8%B7%A8%E8%B6%8A%E4%B8%96%E7%BA%AA%E7%9A%84%E6%A8%A1%E6%8B%9F%E7%BB%8F%E8%90%A5%E6%B8%B8%E6%88%8F%E4%BD%B3%E4%BD%9C/"/>
    <id>https://dew667.github.io/2019/07/12/%E9%9A%8F%E7%AC%94-%E7%BA%AA%E5%85%83%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E8%B7%A8%E8%B6%8A%E4%B8%96%E7%BA%AA%E7%9A%84%E6%A8%A1%E6%8B%9F%E7%BB%8F%E8%90%A5%E6%B8%B8%E6%88%8F%E4%BD%B3%E4%BD%9C/</id>
    <published>2019-07-12T06:49:22.000Z</published>
    <updated>2020-07-05T08:53:41.464Z</updated>
    
    <content type="html"><![CDATA[<p>今天我要推荐的是纪元系列游戏。</p><p>纪元(Anno)是育碧和BlueByte工作室联合开发的模拟经营游戏，目前已经发行了多个作品，如纪元1404、纪元2070、纪元2205以及最新的纪元1800。正如游戏各个作品的名称一样，他们的背景跨越历史和未来，在纪元1404中玩家将在航海纪元纵横，在纪元2070中体验超前的人类科技和深海探索时代，在纪元2205中开发极地和月球上的丰富资源。最新的纪元1800则将时代背景锁定在工业革命时期。</p><a id="more"></a><hr><p>我是早几年接触的纪元1404，后来又购买了纪元2070全套，最近趁着steam夏促打折购入了纪元2205终极版，其中包含了轨道、苔原等全部DLC，推荐大家入手。</p><p>纪元2205将时代背景设定在了距离现在约200年之后的世界。在游戏中玩家任然是以开发经营岛屿工业生产链为主线任务，目标是不断升级人口阶层和数量。在这一作中玩家可以从温带岛屿的建设经营入手，逐步解锁极地建设，苔原建设等。随着工业生产链的完善，可以发送宇航员到空间站并着手建设空间站，或者发射火箭开始建设月球。</p><p><img src="https://s1.ax1x.com/2020/04/10/GoYAkn.png" alt="全球"></p><div style="align:center;"><i>藉由全球视图建立各个生产基地之间的货物运输路线</i></div><br><p><img src="https://s1.ax1x.com/2020/04/10/GoYFTs.png" alt="温带"></p><div style="align:center;"><i>温带基地人口较极地更稠密，产品种类也不同</i></div><br><p><img src="https://s1.ax1x.com/2020/04/10/GoJjYt.png" alt="极地"></p><div style="align:center;"><i>极地庇护帐篷必须搭建在工厂提供的热源范围内，因而更加考验玩家布局能力</i></div><br><p>值得一提的是游戏的画面表现相当不错，各种建筑细节具有相当浓郁的科幻色彩，比如温带和苔原的电力能源都可以由风力发电机提供，温带特殊能源供应装置为潮汐发电站(必须设置在海岸附近)，而极地的特殊供能装置为地热能。</p><p><img src="https://s1.ax1x.com/2020/04/10/GoJvfP.png" alt="极地挖掘"></p><div style="align:center;"><i>极地采矿装置呈现的是多足机械形态，科技美感十足</i></div><br><p><img src="https://s1.ax1x.com/2020/04/10/GoYPmQ.png" alt="空间站"></p><div style="align:center;"><i>游戏中可以发射宇航员到空间站进行建设</i></div><br><hr><p>我认为纪元2205是一款十分出色的续作，让纪元系列能够达到模拟经营类型游戏的巅峰，值得大家尝试。后续我将会带来更多的游戏介绍，包括纪元2070以及最新作纪元1800。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我要推荐的是纪元系列游戏。&lt;/p&gt;
&lt;p&gt;纪元(Anno)是育碧和BlueByte工作室联合开发的模拟经营游戏，目前已经发行了多个作品，如纪元1404、纪元2070、纪元2205以及最新的纪元1800。正如游戏各个作品的名称一样，他们的背景跨越历史和未来，在纪元1404中玩家将在航海纪元纵横，在纪元2070中体验超前的人类科技和深海探索时代，在纪元2205中开发极地和月球上的丰富资源。最新的纪元1800则将时代背景锁定在工业革命时期。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://dew667.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="游戏" scheme="https://dew667.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>JDBC访问数据库(一)</title>
    <link href="https://dew667.github.io/2019/07/12/JDBC%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%B8%80/"/>
    <id>https://dew667.github.io/2019/07/12/JDBC%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%B8%80/</id>
    <published>2019-07-12T06:07:30.000Z</published>
    <updated>2020-07-05T08:53:41.464Z</updated>
    
    <content type="html"><![CDATA[<p>JDBC(Java Data Base Connection)即通过Java访问数据库</p><h4 id="1-导入mysql-jdbc的jar包"><a href="#1-导入mysql-jdbc的jar包" class="headerlink" title="1.导入mysql-jdbc的jar包"></a>1.导入mysql-jdbc的jar包</h4><p>访问MySql官网，找到Connector/J选择合适的版本下载。这里我用的Java8和mysql5.5能够和官网提供的Connector/J5.1.47版本很好地兼容。<a href="https://dev.mysql.com/downloads/connector/j" target="_blank" rel="noopener">下载地址</a><br>通常将项目用到的jar包放在项目的lib目录下，然后在eclipse中导入该jar包<br>导包步骤： 右键project-&gt;property-&gt;java build path-&gt;libaries-&gt;add external jars</p><h4 id="2-初始化驱动"><a href="#2-初始化驱动" class="headerlink" title="2.初始化驱动"></a>2.初始化驱动</h4><p>以下代码是用来初始化驱动的：<br><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code><br>初始化驱动类com.mysql.jdbc.Driver就在之前导入的jar包中<br>初始化b抛出的异常类名为ClassNotFoundException</p><a id="more"></a><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">   </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">           </span><br><span class="line">        &#x2F;&#x2F;初始化驱动</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;驱动类com.mysql.jdbc.Driver</span><br><span class="line">            &#x2F;&#x2F;就在 mysql-connector-java-5.1.47-bin.jar中</span><br><span class="line">            &#x2F;&#x2F;如果忘记了第一个步骤的导包，就会抛出ClassNotFoundException</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">              </span><br><span class="line">            System.out.println(&quot;数据库驱动加载成功 ！&quot;);</span><br><span class="line">   </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F;出错</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-建立与数据库的连接"><a href="#3-建立与数据库的连接" class="headerlink" title="3.建立与数据库的连接"></a>3.建立与数据库的连接</h4><p>需要mysql中已经创建了相应的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 建立与数据库的Connection连接</span><br><span class="line">            &#x2F;&#x2F; 这里需要提供：</span><br><span class="line">            &#x2F;&#x2F; 数据库所处于的ip:localhost:3306 (本机)</span><br><span class="line">            &#x2F;&#x2F; 数据库的端口号： 3306 （mysql专用端口号）</span><br><span class="line">            &#x2F;&#x2F; 数据库名称 jdbc_study</span><br><span class="line">            &#x2F;&#x2F; 账号 root</span><br><span class="line">            &#x2F;&#x2F; 密码 admin</span><br><span class="line">  </span><br><span class="line">            Connection c &#x3D; DriverManager</span><br><span class="line">                    .getConnection(</span><br><span class="line">                            &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc_study&quot;,</span><br><span class="line">                            &quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">  </span><br><span class="line">            System.out.println(&quot;连接成功，获取连接对象： &quot; + c);</span><br><span class="line">  </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-创建Statement"><a href="#4-创建Statement" class="headerlink" title="4.创建Statement"></a>4.创建Statement</h4><p>Statement是用于执行SQL语句的，比如增加，删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">  </span><br><span class="line">            Connection c &#x3D; DriverManager</span><br><span class="line">                    .getConnection(</span><br><span class="line">                            &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc_study&quot;,</span><br><span class="line">                            &quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 注意：使用的是 java.sql.Statement</span><br><span class="line">            &#x2F;&#x2F; 不要不小心使用到： com.mysql.jdbc.Statement;</span><br><span class="line">            Statement s &#x3D; c.createStatement();</span><br><span class="line">  </span><br><span class="line">            System.out.println(&quot;获取 Statement对象： &quot; + s);</span><br><span class="line">  </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-执行SQL语句"><a href="#5-执行SQL语句" class="headerlink" title="5.执行SQL语句"></a>5.执行SQL语句</h4><p>s.execute执行sql语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line">  </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">  </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  </span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">  </span><br><span class="line">            Connection c &#x3D; DriverManager</span><br><span class="line">                    .getConnection(</span><br><span class="line">                            &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc_study&quot;,</span><br><span class="line">                            &quot;root&quot;, &quot;admin&quot;);</span><br><span class="line">  </span><br><span class="line">            Statement s &#x3D; c.createStatement();</span><br><span class="line">  </span><br><span class="line">            &#x2F;&#x2F; 准备sql语句</span><br><span class="line">            &#x2F;&#x2F; 注意： 字符串要用单引号&#39;</span><br><span class="line">    &#x2F;&#x2F;Java变量两侧j用+号，再套上双引号&quot;&quot;</span><br><span class="line">            String sql &#x3D; &quot;insert into hero values(null,&#39;提莫&#39;,&quot;+313.0f+&quot;,&quot;+50+&quot;)&quot;; </span><br><span class="line">            s.execute(sql);</span><br><span class="line">  </span><br><span class="line">            System.out.println(&quot;执行插入语句成功&quot;);</span><br><span class="line">  </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-关闭连接"><a href="#6-关闭连接" class="headerlink" title="6.关闭连接"></a>6.关闭连接</h4><p>关闭连接的顺序：<br>先关闭Statement，后关闭Connection</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line"> </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"> </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        Connection c &#x3D; null;</span><br><span class="line">        Statement s &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"> </span><br><span class="line">            c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc_study&quot;, &quot;root&quot;,</span><br><span class="line">                    &quot;admin&quot;);</span><br><span class="line"> </span><br><span class="line">            s &#x3D; c.createStatement();</span><br><span class="line"> </span><br><span class="line">            String sql &#x3D; &quot;insert into hero values(null,&#39;提莫&#39;,&quot; + 313.0f + &quot;,&quot; + 50 + &quot;)&quot;;</span><br><span class="line"> </span><br><span class="line">            s.execute(sql);</span><br><span class="line"> </span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 数据库的连接时有限资源，相关操作结束后，养成关闭数据库的好习惯</span><br><span class="line">            &#x2F;&#x2F; 先关闭Statement</span><br><span class="line">            if (s !&#x3D; null)</span><br><span class="line">                try &#123;</span><br><span class="line">                    s.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#x2F;&#x2F; 后关闭Connection</span><br><span class="line">            if (c !&#x3D; null)</span><br><span class="line">                try &#123;</span><br><span class="line">                    c.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-查询语句"><a href="#7-查询语句" class="headerlink" title="7.查询语句"></a>7.查询语句</h4><p>executeQuery 执行SQL查询语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package jdbc;</span><br><span class="line"> </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"> </span><br><span class="line">public class TestJDBC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try (Connection c &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;jdbc_study&quot;,</span><br><span class="line">                &quot;root&quot;, &quot;admin&quot;); Statement s &#x3D; c.createStatement();) &#123;</span><br><span class="line"> </span><br><span class="line">            String sql &#x3D; &quot;select * from hero&quot;;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; 执行查询语句，并把结果集返回给ResultSet</span><br><span class="line">            ResultSet rs &#x3D; s.executeQuery(sql);</span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line">                int id &#x3D; rs.getInt(&quot;id&quot;);&#x2F;&#x2F; 可以使用字段名</span><br><span class="line">                String name &#x3D; rs.getString(2);&#x2F;&#x2F; 也可以使用字段的顺序</span><br><span class="line">                float hp &#x3D; rs.getFloat(&quot;hp&quot;);</span><br><span class="line">                int damage &#x3D; rs.getInt(4);</span><br><span class="line">                System.out.printf(&quot;%d\t%s\t%f\t%d%n&quot;, id, name, hp, damage);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 不一定要在这里关闭ReultSet，因为Statement关闭的时候，会自动关闭ResultSet</span><br><span class="line">            &#x2F;&#x2F; rs.close();</span><br><span class="line"> </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDBC(Java Data Base Connection)即通过Java访问数据库&lt;/p&gt;
&lt;h4 id=&quot;1-导入mysql-jdbc的jar包&quot;&gt;&lt;a href=&quot;#1-导入mysql-jdbc的jar包&quot; class=&quot;headerlink&quot; title=&quot;1.导入mysql-jdbc的jar包&quot;&gt;&lt;/a&gt;1.导入mysql-jdbc的jar包&lt;/h4&gt;&lt;p&gt;访问MySql官网，找到Connector/J选择合适的版本下载。这里我用的Java8和mysql5.5能够和官网提供的Connector/J5.1.47版本很好地兼容。&lt;a href=&quot;https://dev.mysql.com/downloads/connector/j&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载地址&lt;/a&gt;&lt;br&gt;通常将项目用到的jar包放在项目的lib目录下，然后在eclipse中导入该jar包&lt;br&gt;导包步骤： 右键project-&amp;gt;property-&amp;gt;java build path-&amp;gt;libaries-&amp;gt;add external jars&lt;/p&gt;
&lt;h4 id=&quot;2-初始化驱动&quot;&gt;&lt;a href=&quot;#2-初始化驱动&quot; class=&quot;headerlink&quot; title=&quot;2.初始化驱动&quot;&gt;&lt;/a&gt;2.初始化驱动&lt;/h4&gt;&lt;p&gt;以下代码是用来初始化驱动的：&lt;br&gt;&lt;code&gt;Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);&lt;/code&gt;&lt;br&gt;初始化驱动类com.mysql.jdbc.Driver就在之前导入的jar包中&lt;br&gt;初始化b抛出的异常类名为ClassNotFoundException&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="https://dew667.github.io/tags/Java/"/>
    
      <category term="JDBC" scheme="https://dew667.github.io/tags/JDBC/"/>
    
      <category term="数据库" scheme="https://dew667.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Windows10的Linux子系统体验</title>
    <link href="https://dew667.github.io/2019/06/21/Windows10%E7%9A%84Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BD%93%E9%AA%8C/"/>
    <id>https://dew667.github.io/2019/06/21/Windows10%E7%9A%84Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BD%93%E9%AA%8C/</id>
    <published>2019-06-20T16:06:48.000Z</published>
    <updated>2020-07-05T08:53:41.480Z</updated>
    
    <content type="html"><![CDATA[<p>新版的Windows10支持Linux子系统，可以直接在Windows系统中启用Linux系统，省去了双系统切换的麻烦，或者避免了安装虚拟机。</p><a id="more"></a><h4 id="1-开启Linux子系统设置"><a href="#1-开启Linux子系统设置" class="headerlink" title="1.开启Linux子系统设置"></a>1.开启Linux子系统设置</h4><p>控制面板-&gt;程序和功能-&gt;启用或关闭Windows功能-&gt;勾选 适用于Linux的Windows子系统<br><img src="https://s1.ax1x.com/2020/04/10/GoJXFI.png" alt="pic"><br>重启电脑</p><h4 id="2-在应用商店安装Linux"><a href="#2-在应用商店安装Linux" class="headerlink" title="2.在应用商店安装Linux"></a>2.在应用商店安装Linux</h4><p>在应用商店搜索Linux，选择安装Ubuntu。</p><h4 id="3-启动Linux"><a href="#3-启动Linux" class="headerlink" title="3.启动Linux"></a>3.启动Linux</h4><ul><li>在cmd或power shell中输入<code>bash</code>启动</li><li>直接点击Ubuntu启动图标启动</li></ul><p>完成用户密码设置即可使用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新版的Windows10支持Linux子系统，可以直接在Windows系统中启用Linux系统，省去了双系统切换的麻烦，或者避免了安装虚拟机。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://dew667.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>如何将hexo博客迁移到新的电脑上</title>
    <link href="https://dew667.github.io/2019/06/16/%E5%A6%82%E4%BD%95%E5%B0%86hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E6%96%B0%E7%9A%84%E7%94%B5%E8%84%91%E4%B8%8A/"/>
    <id>https://dew667.github.io/2019/06/16/%E5%A6%82%E4%BD%95%E5%B0%86hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E6%96%B0%E7%9A%84%E7%94%B5%E8%84%91%E4%B8%8A/</id>
    <published>2019-06-16T04:42:36.000Z</published>
    <updated>2020-07-05T08:53:41.464Z</updated>
    
    <content type="html"><![CDATA[<p>最近购入了一台新的笔记本电脑。现在面临将我的hexo博客迁移到新的笔记本电脑上的问题。<br>我需要将原来电脑Linux系统中的博客转移到新电脑上，并且我的新电脑也已经装好了Linux环境，只不过是在Windows10上的Linux子系统（WSL）。</p><h4 id="1-在新电脑Linux环境下安装必要软件"><a href="#1-在新电脑Linux环境下安装必要软件" class="headerlink" title="1.在新电脑Linux环境下安装必要软件"></a>1.在新电脑Linux环境下安装必要软件</h4><p>参照我的<a href="http://dew667.xyz/2019/05/25/在Linux上搭建我的hexo博客/" target="_blank" rel="noopener">上一篇文章</a>正确安装Git、Nodejs、hexo等<br>在<code>/home/username</code>目录下新建博客文件夹<code>mkdir blog</code></p><a id="more"></a><h4 id="2-拷贝hexo博客文件"><a href="#2-拷贝hexo博客文件" class="headerlink" title="2.拷贝hexo博客文件"></a>2.拷贝hexo博客文件</h4><p>进入blog目录<code>cd /home/username/blog</code><br>初始化博客<code>hexo init</code><br>拷贝原来电脑的blog文件下的这些文件到新电脑的blog目录覆盖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scaffolds    文章模板</span><br><span class="line">source       博客文章</span><br><span class="line">themes       主题</span><br><span class="line">.gitignore</span><br><span class="line">_config.yml  站点配置文件</span><br><span class="line">package.json 安装包的名称</span><br></pre></td></tr></table></figure><p>拷贝这些文件的方式有：</p><ul><li>通过网盘传，需要将blog文件打包后上传到网盘，避免文件数上传超过限制</li><li>用Linux的scp命令传文件，需要处在同一局域网</li><li>用U盘拷贝，涉及到Linux设备挂载</li></ul><h4 id="3-重新安装插件"><a href="#3-重新安装插件" class="headerlink" title="3.重新安装插件"></a>3.重新安装插件</h4><p>首先初始换git本地仓库<br><code>git init</code><br>安装上传插件<br><code>cnpm install hexo-deployer-git --save</code><br>安装其他插件，如我用的yilia主题中所有文章目录显示需要的插件</p><h4 id="4-完成迁移"><a href="#4-完成迁移" class="headerlink" title="4.完成迁移"></a>4.完成迁移</h4><p>重启博客即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近购入了一台新的笔记本电脑。现在面临将我的hexo博客迁移到新的笔记本电脑上的问题。&lt;br&gt;我需要将原来电脑Linux系统中的博客转移到新电脑上，并且我的新电脑也已经装好了Linux环境，只不过是在Windows10上的Linux子系统（WSL）。&lt;/p&gt;
&lt;h4 id=&quot;1-在新电脑Linux环境下安装必要软件&quot;&gt;&lt;a href=&quot;#1-在新电脑Linux环境下安装必要软件&quot; class=&quot;headerlink&quot; title=&quot;1.在新电脑Linux环境下安装必要软件&quot;&gt;&lt;/a&gt;1.在新电脑Linux环境下安装必要软件&lt;/h4&gt;&lt;p&gt;参照我的&lt;a href=&quot;http://dew667.xyz/2019/05/25/在Linux上搭建我的hexo博客/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt;正确安装Git、Nodejs、hexo等&lt;br&gt;在&lt;code&gt;/home/username&lt;/code&gt;目录下新建博客文件夹&lt;code&gt;mkdir blog&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="https://dew667.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>在Linux上搭建我的hexo博客</title>
    <link href="https://dew667.github.io/2019/05/25/%E5%9C%A8Linux%E4%B8%8A%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>https://dew667.github.io/2019/05/25/%E5%9C%A8Linux%E4%B8%8A%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-05-25T04:59:19.000Z</published>
    <updated>2020-07-05T08:53:41.480Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将会介绍我是如何在Linux上搭建hexo个人博客系统的，我用的操作系统是deepin Linux。</p><h4 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h4><p>Git是目前广泛使用的分布式版本控制系统<br>首先在Linux终端输入以下代码，检测是否已经安装了Git<br><code>git</code><br>安装Git方法如下:<br><code>sudo apt-get install git</code></p><a id="more"></a><h4 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h4><p>Node官网已经把linux下载版本更改为已编译好的版本了，我们可以直接下载解压后使用。<br>用浏览器导航到<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Node.js中文网</a>下载对应的压缩包文件(选择下载Linux二进制文件x64这一项)<br><img src="https://s1.ax1x.com/2020/04/10/GoYSl8.png" alt="Node.js中文网下载页"><br>下载完成后拷贝压缩包到/opt目录下并进行解压：<br><code>sudo cp 下载路径/node-v10.15.3-linux-x64.tar.xz /opt</code><br><code>sudo tar xf node-v10.15.3-linux-x64.tar.xz</code><br>解压完成后解压文件的bin目录下包含了node、npm等命令，我们用ln命令来设置软连接:<br><code>ln -s /opt/node-v10.15.3-linux-x64/bin/npm /usr/local/bin/</code><br><code>ln -s /opt/node-v10.15.3-linux-x64/bin/node /usr/local/bin/</code><br>执行node命令，查看版本，检查是否安装成功：<br><code>node -v</code><br><code>npm -v</code></p><h4 id="3-安装cnpm"><a href="#3-安装cnpm" class="headerlink" title="3.安装cnpm"></a>3.安装cnpm</h4><p>这里为避免安装hexo过慢，采用淘宝npm镜像源，先利用npm安装cnpm<br>先进入管理员模式，获取权限<br><code>sudo su</code><br>接下来进行安装:<br><code>npm install -g cnpm --registry==https://registry.npm.taobao.org</code><br>设置软连接：<br><code>ln -s /opt/node-v10.15.3-linux-x64/bin/cnpm /usr/local/bin/</code><br>安装完成，查看版本:<br><code>cnpm -v</code></p><h4 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="4.安装hexo"></a>4.安装hexo</h4><p>下面利用cnpm安装hexo<br><code>cnpm install -g hexo-cli</code><br>设置软连接：<br><code>ln -s /opt/node-v10.15.3-linux-x64/bin/hexo /usr/local/bin/</code><br>查看版本，验证:<br><code>hexo -v</code></p><h4 id="5-正式搭建博客"><a href="#5-正式搭建博客" class="headerlink" title="5. 正式搭建博客"></a>5. 正式搭建博客</h4><p>进入用户路径，创建blog目录(出现问题可删除该目录并重新建立)<br><code>mkdir blog</code><br>进入blog目录<br><code>cd blog</code><br>生成hexo博客<br><code>sudo hexo init</code><br>启动博客<br><code>hexo s</code><br>启动成功可在本地访问博客页面(localhost:4000)<br>建立第一篇博客文章<br><code>hexo new &quot;我的第一篇博客文章&quot;</code><br>编辑文章，先进入文章目录blog/source/_posts:<br><code>cd source/_posts</code><br>再使用markdown编辑器或vim编辑:<br><code>vim 我的第一篇博客文章.md</code><br>编辑完成按一下步骤重启博客<br><code>hexo clean</code><br><code>hexo g</code><br><code>hexo s</code></p><h4 id="6-将博客部署到Github"><a href="#6-将博客部署到Github" class="headerlink" title="6.将博客部署到Github"></a>6.将博客部署到Github</h4><p>首先注册Github账号<br>建立一个新的仓库new repository<br>注意repository name要与Github用户名一致<br>如dew667.github.io<br><img src="https://s1.ax1x.com/2020/04/10/GoJzSf.png" alt="Github"><br>安装deployer插件：<br><code>cnpm install --save hexo-deployer-git</code><br>设置配置文件_config.yml:<br><code>vim _config.yml</code><br>找到＃Deployment,修改type项为git<br>repo项设置为Github仓库地址如<a href="https://github.com/dew667/dew667.github.io.git" target="_blank" rel="noopener">https://github.com/dew667/dew667.github.io.git</a><br>添加branch项为master<br>下面部署到github:<br><code>hexo d</code><br>成功后即可访问dew667.github.io查看博客页面</p><h4 id="7-更换hexo博客主题"><a href="#7-更换hexo博客主题" class="headerlink" title="7.更换hexo博客主题"></a>7.更换hexo博客主题</h4><p>这里选用yilia主题<br>首先克隆到本地blog/themes/yilia目录<br><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code><br>编辑blog目录下的_config.yml<br>更改theme项为yilia<br>重新启动博客即可<code>hexo clean</code> <code>hexo g</code> <code>hexo d</code><br>针对yilia主题所有文章显示问题,根据主题提示用cnpm安装插件并修改_config.yml文档后即可</p><hr><p>以上就是我建立hexo个人博客的具体步骤，后续将探讨如何部署到云服务器上并使用新的域名。谢谢大家！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章将会介绍我是如何在Linux上搭建hexo个人博客系统的，我用的操作系统是deepin Linux。&lt;/p&gt;
&lt;h4 id=&quot;1-安装Git&quot;&gt;&lt;a href=&quot;#1-安装Git&quot; class=&quot;headerlink&quot; title=&quot;1.安装Git&quot;&gt;&lt;/a&gt;1.安装Git&lt;/h4&gt;&lt;p&gt;Git是目前广泛使用的分布式版本控制系统&lt;br&gt;首先在Linux终端输入以下代码，检测是否已经安装了Git&lt;br&gt;&lt;code&gt;git&lt;/code&gt;&lt;br&gt;安装Git方法如下:&lt;br&gt;&lt;code&gt;sudo apt-get install git&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="https://dew667.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>欢迎大家访问我的hexo博客</title>
    <link href="https://dew667.github.io/2019/05/25/%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E8%AE%BF%E9%97%AE%E6%88%91%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>https://dew667.github.io/2019/05/25/%E6%AC%A2%E8%BF%8E%E5%A4%A7%E5%AE%B6%E8%AE%BF%E9%97%AE%E6%88%91%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-05-25T01:50:57.000Z</published>
    <updated>2020-07-05T08:53:41.464Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/10/GoJbeH.jpg" alt="welcome"></p><p>我是华中科技大学软件学院准硕士研究生，同时也是一名跨考生。目前正在努力学习软件工程和计算机相关知识，志在深耕Java后端技术。我将会在博客上分享一些学习心得和其他内容，欢迎大家关注。</p><hr><p>我的邮箱: <a href="mailto:dew_wang667@126.com">dew_wang667@126.com</a><br>我的微信: dew_wang00</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/04/10/GoJbeH.jpg&quot; alt=&quot;welcome&quot;&gt;&lt;/p&gt;
&lt;p&gt;我是华中科技大学软件学院准硕士研究生，同时也是一名跨考生。目前正在努力学习软件工程和计算机相关知识，志在深耕Java后端技术
      
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://dew667.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
