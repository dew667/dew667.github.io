<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Java常见基础知识(续) · ColorfulCat</title><meta name="description" content="云外有天，年月有歌"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://dew667.github.io/atom.xml" title="ColorfulCat"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="ColorfulCat" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/dew667" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/links/" target="_self" class="nav-list-link">LINKS</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Java常见基础知识(续)</h1><div class="post-info">Jul 5, 2020</div><div class="post-content"><h3 id="26-为什么Java中只有值传递？"><a href="#26-为什么Java中只有值传递？" class="headerlink" title="26.为什么Java中只有值传递？"></a>26.为什么Java中只有值传递？</h3><p>Java中方法采用是值传递而不是引用调用，即方法接收的是参数的一份拷贝。<br>总结：</p>
<ul>
<li>Java中方法不能修改一个基本数据类型的参数。</li>
<li>Java中方法可以改变一个对象参数的状态。</li>
<li>Java中方法不能让对象参数引用一个新的对象。</li>
</ul>
<a id="more"></a>

<h3 id="27-简述程序、进程、线程的概念。以及它们之间的关系？"><a href="#27-简述程序、进程、线程的概念。以及它们之间的关系？" class="headerlink" title="27.简述程序、进程、线程的概念。以及它们之间的关系？"></a>27.简述程序、进程、线程的概念。以及它们之间的关系？</h3><ul>
<li>程序<br>程序可以定义为算法加数据，一个程序可以是存放在计算机存储空间中的代码集合，例如浏览器就是一个程序。</li>
<li>进程<br>计算机操作系统可以实现多任务功能。为了实现多任务，操作系统必须利用好CPU，可以通过CPU分时或者多核CPU来实现。而一个任务可以理解为一个进程。操作系统为一个进程分配一定的内存存储空间和CPU时间以及文件、设备的控制权。进程通过这些资源实现自己的任务功能。</li>
<li>线程<br>线程可以理解为一个进程中更细粒度的运行单位。一个进程可以通过多个线程同时执行多个子功能模块。多个线程共享进程的内存存储空间、系统资源，因而线程之间通信和切换等操作比较方便。</li>
<li>进程、线程之间的关系<br>进程是操作系统执行多任务的基本运行单位，而线程是进程内更细粒度的基本运行单位。操作系统为进程分配内存存储空间、CPU时间、文件和设备控制器等资源，进程内部的线程共享该进程的内存存储空间等资源。线程之间通信和切换操作相较进程之间更加方便。</li>
</ul>
<h3 id="28-线程有哪些基本状态？"><a href="#28-线程有哪些基本状态？" class="headerlink" title="28.线程有哪些基本状态？"></a>28.线程有哪些基本状态？</h3><ol>
<li>Java中线程的基本状态有NEW、RUNNABLE、WAITING、TIMED_WAITING、BLOCKED、TERMINATED。即初始状态、运行状态、等待状态、超时等待状态、阻塞状态、终止状态。  </li>
</ol>
<table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center">名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NEW</td>
<td align="center">初始状态</td>
<td align="center">线程被创建但还未调用start()方法</td>
</tr>
<tr>
<td align="center">RUNNABLE</td>
<td align="center">运行状态</td>
<td align="center">Java中将就绪状态和运行状态笼统地称为RUNNABLE状态</td>
</tr>
<tr>
<td align="center">WAITING</td>
<td align="center">等待状态</td>
<td align="center">线程等待其他线程的通知</td>
</tr>
<tr>
<td align="center">TIMED_WAITING</td>
<td align="center">超时等待状态</td>
<td align="center">等待一段时间线程可以自行回到RUNNABLE状态</td>
</tr>
<tr>
<td align="center">BLOCKED</td>
<td align="center">阻塞状态</td>
<td align="center">线程执行同步方法时，未获取到锁则进入阻塞状态</td>
</tr>
<tr>
<td align="center">TERMINATED</td>
<td align="center">终止状态</td>
<td align="center">线程执行结束</td>
</tr>
</tbody></table>
<p><img src="https://s1.ax1x.com/2020/04/10/GoY9Og.png" alt="java线程">  </p>
<blockquote>
<p>线程创建之后，进入NEW状态，即初始状态。调用start()方法后线程进入READY状态(就绪状态)，当分配到CPU时间片后，即进入RUNNING状态(运行)。在Java中，把READY和RUNNING状态笼统地称为RUNNABLE状态。如果线程执行wait()方法，则线程进入WAITING状态(等待状态)。在此状态下只有其它线程通知，才能回到运行状态。TIMED_WAITING状态(超时等待状态)则是在WAITING状态基础上加上时间限制，例如sleep(long)，当时间到后线程回到运行状态。如果线程要调用同步方法而没有获取到锁，则进入BLOCKED(阻塞状态)。在此状态下如果获取到锁则回到运行状态。线程执行完毕，进入TERMINATED状态(终止状态)。</p>
</blockquote>
<h3 id="29-关于final关键字的一些总结"><a href="#29-关于final关键字的一些总结" class="headerlink" title="29.关于final关键字的一些总结"></a>29.关于final关键字的一些总结</h3><p>final关键字用法有三种：用于变量、用于类、用于方法。  </p>
<ol>
<li>final关键字用于变量<br>final用于基本数据类型变量时，变量一旦被初始化就不能再修改。如果用于引用类型变量，则引用类型变量一旦初始化对象后就不能再更改引用指向。</li>
<li>final关键字用于类<br>final关键字用于类时，表明该类不能被继承。另外，final关键字修饰的类中的方法都隐式地指定为final</li>
<li>final关键字用于方法<br>final关键字用于方法，则该方法不能被子类重写。private修饰的方法都被隐式地指定为final。</li>
</ol>
<h3 id="30-Java异常处理"><a href="#30-Java异常处理" class="headerlink" title="30.Java异常处理"></a>30.Java异常处理</h3><ul>
<li>Java异常结构层次<br><img src="https://s1.ax1x.com/2020/04/10/GoYiwj.png" alt="Java异常处理"></li>
<li>Java异常处理<br>Java中所有异常都有一个共同的祖先，即java.lang包中的Throwable类。Thorwable有两个重要的子类Error和Exception。Error是程序无法处理的错误，一般是程序运行时JVM发生的错误，如内存用尽时OutOfMemoryError。Exception是程序可以处理的异常，如要访问的变量没有引用任何对象时NullPointerException。<br>Error和Exception之间的不同之处是Error是程序本身不可以处理的错误，而Exception是程序本身可以处理的异常。  </li>
<li>Throwable类常用方法  <ol>
<li>public String getMessage() 返回异常发生时的简要描述</li>
<li>public String toString() 返回异常发生时的详细信息</li>
<li>public void printStackTrace() 在控制台上打印Throwable对象封装的异常信息</li>
</ol>
</li>
<li>Try-Catch块的使用<br>try块用于捕获异常，其后可接一个或多个catch块。如果没有接catch块，则其后必须接finally块。<br>catch块用于处理异常。<br>finally块：无论是否捕获或处理异常，finally块中的语句都会被执行。如果在之前try块或catch块中已有return语句，则finally块中的内容会在return之前先执行。如果不仅try块中有return语句，而且finally块中也有return语句，则返回前先执行finally块内容，finally块中的return语句代替try中return。  </li>
<li>不会执行finally块的情况<ol>
<li>finally块中第1行语句发生异常。</li>
<li>前面已用System.exit(int)退出程序</li>
<li>所在线程死亡</li>
<li>CPU关闭</li>
</ol>
</li>
</ul>
<h3 id="31-Java序列化中如果有些字段不想序列化，怎么办？"><a href="#31-Java序列化中如果有些字段不想序列化，怎么办？" class="headerlink" title="31.Java序列化中如果有些字段不想序列化，怎么办？"></a>31.Java序列化中如果有些字段不想序列化，怎么办？</h3><p>对实例中不想进行序列化的字段使用transient关键字修饰。<br>transient关键字只能修饰变量，不能修饰类和方法。</p>
<h3 id="32-获取键盘输入常用的方法？"><a href="#32-获取键盘输入常用的方法？" class="headerlink" title="32.获取键盘输入常用的方法？"></a>32.获取键盘输入常用的方法？</h3><ul>
<li>Scanner  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<ul>
<li>BufferedReader  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input &#x3D; new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">String s &#x3D; input.readLine();</span><br></pre></td></tr></table></figure>

<h3 id="33-Java中IO流分为几种？"><a href="#33-Java中IO流分为几种？" class="headerlink" title="33.Java中IO流分为几种？"></a>33.Java中IO流分为几种？</h3><ul>
<li>分类  <ol>
<li>按照方向分为输入流和输出流</li>
<li>按照操作单位分为字符流和字节流</li>
<li>按照流的角色分为节点流和处理流</li>
</ol>
</li>
<li>为什么有了字节流还要有字符流<br>因为字符流是Java虚拟机通过字节流转换而来的，转换过程比较费时而且不知道编码的情况下容易乱码，所以Java索性提供了字符流接口。</li>
</ul>
<h3 id="34-BIO、NIO、AIO有什么区别"><a href="#34-BIO、NIO、AIO有什么区别" class="headerlink" title="34.BIO、NIO、AIO有什么区别?"></a>34.BIO、NIO、AIO有什么区别?</h3><ul>
<li>BIO<br>BIO是指同步阻塞IO模式。这种模式下，数据操作必须阻塞在一个线程内等待其完成。即需要维持一个连接，而且客户端不能做其他事情。BIO模式的优点是使用起来直观、简单，能够应对并发量较小的情况。缺点是，当并发量过大时服务器负担较大，无法很好地应对。</li>
<li>NIO<br>NIO是指同步非阻塞IO模式。这种模式下，客户端与服务端之间不需要保持一个连接，而是分成许多小的连接。客户端向服务端轮询，如果没有数据则断开连接，直到有数据为止。客户端与服务端不需要维持连接，客户端也不可以做其他事情。NIO模型相较BIO能够更好地应对高负载、高并发的情况。</li>
<li>AIO<br>AIO是指异步非阻塞IO模型。在这种模式下，客户端与服务端之间不用保持连接，也不用轮询方式。而是在服务端处理完成后能够通知客户端并返回数据。客户端在得到数据之前可以做其他事情。目前来说，AIO应用并不广泛。  </li>
</ul>
<h3 id="35-常见关键字总结：final、static、this、super"><a href="#35-常见关键字总结：final、static、this、super" class="headerlink" title="35.常见关键字总结：final、static、this、super"></a>35.常见关键字总结：final、static、this、super</h3><ul>
<li>final<br>final关键字主要可以用在三个地方:变量、类、方法.<ul>
<li>final关键字用于变量： final关键字如果用于基本数据类型的变量，则该变量一旦初始化，就不可以修改其值；如果用于引用类型变量，则一旦该变量初始化，就不可以改变引用对象。</li>
<li>final关键字用于类： final关键字用于类，表明该类不可以被继承。并且final关键字修饰的类，其中的方法隐式地被修饰final关键字。</li>
<li>final关键字用于方法： final关键字修饰方法，主要有两个作用。一是表明该方法不可被子类重写。二是在早期Java版本中，使用内嵌调用方式以提高性能。</li>
</ul>
</li>
<li>static<br>static关键字可以用在四个地方：修饰类的成员、静态代码块、修饰内部类、静态导包  <ul>
<li>static关键字用于修饰类的成员： static修饰类的成员时，这些成员属于类而不属于类的实例对象，可以用类名.成员名的方式访问这些成员。如果static修饰的是成员变量，则成员变量存放在内存方法区中。如果static修饰的是成员方法，则在该方法内只能访问static修饰的变量或方法。</li>
<li>static关键字用于静态代码块： 静态代码块是在非静态代码块之前执行，且对于一个类的所有实例对象只执行一次。</li>
<li>static关键字用于内部类： static修饰内部类，则该内部类不具有外部类的引用，因此该内部类的创建不需要依赖外部类，同时该内部类只能访问外部类的static修饰的成员。</li>
<li>static关键字用于静态导包： 静态导包可以不需要通过类名来访问其中的成员。</li>
</ul>
</li>
<li>this<br>this关键字用于引用类的当前实例。</li>
<li>super<br>super关键字用于子类访问父类的成员。  </li>
</ul>
<h3 id="36-深拷贝和浅拷贝"><a href="#36-深拷贝和浅拷贝" class="headerlink" title="36.深拷贝和浅拷贝"></a>36.深拷贝和浅拷贝</h3><p>拷贝一个对象时分为深拷贝和浅拷贝</p>
<ul>
<li>浅拷贝<br>浅拷贝是指拷贝时，对基本数据类型的拷贝以值传递方式进行，而拷贝引用类型则只是对引用进行传递，因此拷贝前后两个对象中的引用类型仍然指向同一个对象，对两个对象中引用对象的数据进行修改会相互影响。</li>
<li>深拷贝<br>深拷贝是指拷贝时，对基本数据类型的拷贝以值传递方式进行，并且拷贝引用类型变量时新建一个对象的空间并复制其中的内容。这样两个对象中引用的对象不是同一个。</li>
<li>浅拷贝和深拷贝的一种实现方式是类实现Cloneable接口，并且重写clone()方法。如果要做到深拷贝，则引用类型也需要实现Cloneable接口并重写clone()方法。</li>
</ul>
<p><strong>参考</strong></p>
<p>[1] JavaGuide面试突击版[<a href="https://gitee.com/SnailClimb/JavaGuide]" target="_blank" rel="noopener">https://gitee.com/SnailClimb/JavaGuide]</a>(</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/04/10/Java%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2020 <a href="https://dew667.github.io">ColorfulCat</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>