<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ColorfulCat</title><meta name="description" content="云外有天，年月有歌"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://dew667.github.io/atom.xml" title="ColorfulCat"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="ColorfulCat" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/dew667" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/links/" target="_self" class="nav-list-link">LINKS</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" class="post-title-link">设计模式之策略模式</a></h2><div class="post-info">Aug 21, 2020</div><div class="post-content"><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。</p>
<p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>
<h3 id="2-举例"><a href="#2-举例" class="headerlink" title="2.举例"></a>2.举例</h3><p>在Head First 设计模式中提供了鸭子游戏的例子。</p></div><a href="/2020/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/07/17/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" class="post-title-link">进程和线程</a></h2><div class="post-info">Jul 17, 2020</div><div class="post-content"><h3 id="1-什么是进程和线程"><a href="#1-什么是进程和线程" class="headerlink" title="1. 什么是进程和线程"></a>1. 什么是进程和线程</h3><ul>
<li><p>进程是程序的一次执行过程，是系统运行程序的基本单位。在Java中，执行main函数即是启动了一个JVM进程。</p>
</li>
<li><p>线程是进程中更小的执行单位，一个进程可以产生多个线程。进程是资源分配的最小单位，而线程CPU执行时的最小单位。从JVM角度看，线程可以共享进程中的堆和元空间等，而每个线程拥有自己独立的虚拟机栈和本地方法栈以及程序计数器。由于多个线程可以共享进程的一些资源，所以各个线程之间切换更加轻量，要比进程负担更小。 </p></div><a href="/2020/07/17/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/07/08/ConcurrentHashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link">ConcurrentHashMap和HashTable的区别</a></h2><div class="post-info">Jul 8, 2020</div><div class="post-content"><ul>
<li>ConcurrentHashMap和HashTable的区别<br>ConcurrentHashMap和Hashtable的主要区别在于实现线程安全性的方式不同。</li>
<li>底层数据结构：<br>JDK1.7的ConcurrentHashMap底层数据结构采用分段的数组+链表实现，JDK1.8的ConcurrentHashMap底层数据结构采用和HashMap一样的方式实现，即数组+链表/红黑树。Hashtable的底层数据结构则和JDK1.8之前的HashMap一样，采用数组+链表的方式。</div><a href="/2020/07/08/ConcurrentHashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/07/07/HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" class="post-title-link">HashMap的底层实现</a></h2><div class="post-info">Jul 7, 2020</div><div class="post-content"><ul>
<li><p>HashMap底层是数组加链表组合起来使用的。当向HashMap中put一个键值对时，会计算出key的hashCode，然后通过扰动函数对hashCode值进行处理，以达到尽可能散列的目的，从而得到当前元素在数组中存储的位置。如果在该位置遇到已经存在的元素，则判断hash值以及Key是否相同，如果相同则覆盖之，不相同则采用“拉链法”解决冲突。</p></div><a href="/2020/07/07/HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/07/07/HashMap%E3%80%81Hashtable%E3%80%81HashSet%E6%AF%94%E8%BE%83/" class="post-title-link">HashMap、Hashtable、HashSet比较</a></h2><div class="post-info">Jul 7, 2020</div><div class="post-content"><h3 id="HashMap-Hashtable-HashSet继承实现关系"><a href="#HashMap-Hashtable-HashSet继承实现关系" class="headerlink" title="HashMap Hashtable HashSet继承实现关系"></a>HashMap Hashtable HashSet继承实现关系</h3><p>下面是三者的继承实现关系示意图</p></div><a href="/2020/07/07/HashMap%E3%80%81Hashtable%E3%80%81HashSet%E6%AF%94%E8%BE%83/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/07/07/%E8%AF%B4%E4%B8%80%E8%AF%B4ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/" class="post-title-link">说一说ArrayList的扩容机制</a></h2><div class="post-info">Jul 7, 2020</div><div class="post-content"><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md" target="_blank" rel="noopener">ArrayList 扩容机制源码分析</a>  </p>
<ul>
<li><p>通过ArrayList构造方法初始化时，可以带初始容量，则为ArrayList列表设置指定初始容量。</p>
</li>
<li><p>如果通过ArrayList构造方法初始化，不带初始容量参数，则ArrayList列表中的数据初始化为空的Object[]数组，其长度为0，即DEFEAULTCAPACITY_ELEMENT_DATA。之后在第一次调用add()方法添加元素时才会初始化数组容量为默认大小10.</p></div><a href="/2020/07/07/%E8%AF%B4%E4%B8%80%E8%AF%B4ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/07/06/ArrayList-Vector-LinkedList%E9%9B%86%E5%90%88%E7%9A%84%E6%AF%94%E8%BE%83/" class="post-title-link">ArrayList,Vector,LinkedList集合的比较</a></h2><div class="post-info">Jul 6, 2020</div><div class="post-content"><h3 id="ArrayList、Vector、LinkedList三者的继承实现关系"><a href="#ArrayList、Vector、LinkedList三者的继承实现关系" class="headerlink" title="ArrayList、Vector、LinkedList三者的继承实现关系"></a>ArrayList、Vector、LinkedList三者的继承实现关系</h3><p>ArrayList、LinkedList、Vector都实现了List接口，而LinkedList还实现了Queue接口。因而，ArrayList、Vector都有列表的基本方法add、remove、get、set等，LinkedList除具有List的基本方法外还有队列的一些方法如poll、peek等。 </p></div><a href="/2020/07/06/ArrayList-Vector-LinkedList%E9%9B%86%E5%90%88%E7%9A%84%E6%AF%94%E8%BE%83/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/07/05/Java%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%BB%AD/" class="post-title-link">Java常见基础知识(续)</a></h2><div class="post-info">Jul 5, 2020</div><div class="post-content"><h3 id="26-为什么Java中只有值传递？"><a href="#26-为什么Java中只有值传递？" class="headerlink" title="26.为什么Java中只有值传递？"></a>26.为什么Java中只有值传递？</h3><p>Java中方法采用是值传递而不是引用调用，即方法接收的是参数的一份拷贝。<br>总结：</p>
<ul>
<li>Java中方法不能修改一个基本数据类型的参数。</li>
<li>Java中方法可以改变一个对象参数的状态。</li>
<li>Java中方法不能让对象参数引用一个新的对象。</li>
</ul></div><a href="/2020/07/05/Java%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%BB%AD/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/04/10/Java%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link">Java常见基础知识</a></h2><div class="post-info">Apr 10, 2020</div><div class="post-content"><h3 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1.面向对象和面向过程的区别"></a>1.面向对象和面向过程的区别</h3><ul>
<li><p>面向过程相较面向对象通常资源开销较小，性能更占优势。因为面向对象中类的调用需要实例化。通常用在嵌入式、底层开发等对资源占用或性能要求较高的场合。</p>
</li>
<li><p>面向对象更加易于维护、扩展和复用，因为面向对象加入了封装、继承、多态等特性。面向对象语言可以设计出更加灵活、易于维护和扩展的系统。</p></div><a href="/2020/04/10/Java%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/12/28/%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/" class="post-title-link">记一次使用IDEA部署SSM项目时遇到的问题</a></h2><div class="post-info">Dec 28, 2019</div><div class="post-content"><blockquote class="blockquote-center">寒雨连江夜入吴，平明送客楚山孤。洛阳亲友如相问，一片冰心在玉壶。 
    《芙蓉楼送新辛渐》—— 王昌龄</blockquote>

<hr>
<p>本文介绍我在一次导入SSM项目时遇到的问题。（踩坑记录）</p>
<h4 id="IDEA导入SSM项目"><a href="#IDEA导入SSM项目" class="headerlink" title="IDEA导入SSM项目"></a>IDEA导入SSM项目</h4><hr>
<p>我要导入的项目是一个Github上的一个聊天室项目 <a href="https://github.com/MrLiu1227/WebChat" target="_blank" rel="noopener">Github链接</a> 首先import项目，选择Maven项目，勾选Import Maven projects automatically选项以及Automatically download的两个选项 </p></div><a href="/2019/12/28/%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2020 <a href="https://dew667.github.io">ColorfulCat</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>